<?php
/*
 * A PHP file for testing out ProductOptionsVariantsImporter
 */

use NorthCommerce\Db\Collections\ProductOptionTypes;
use NorthCommerce\Db\Collections\ProductVariantTypes;
use NorthCommerce\Importers\ProductOptionsVariantsImporter;

require_once(__DIR__ . '/../../north-commerce-test-case.php');

class ProductOptionsVariantsImporterTest extends North_Commerce_Test_case
{

	private $localIdSource;
	private ProductOptionsVariantsImporter $importer;

	public function setUp(): void
	{
		parent::setUp();
		$this->localIdSource = 0;
		$this->importer = new ProductOptionsVariantsImporter();
	}

	public function testImportHasNoVariants()
	{
		$product = $this->ef->newProduct(['variants' => false]);

		$data = $this->makeData($product, [
			['name' => "Grade",
			 'product_option_values' => [
				 ['value' => "A"],
				 ['value' => "C"]
			]]
		]);
		unset($data['has_product_variants']);


		$this->importer->import($data);

		$solo_pv = $this->ea->get('product_variants', [
			'product.id' => $product['id'],
			'product_variant_type_id' => ProductVariantTypes::solo()->id
		]);

		$this->assertIsNumeric($solo_pv['id']);


		$all_pv = $this->ea->list('product_variants', [
			'product.id' => $product['id'],
			'product_variant_type_id' => ProductVariantTypes::standard()->id
		]);
		$this->assertCount(2, $all_pv);

		$product = $this->ea->get('products', ['id' => $product['id']]);
		$this->assertEquals(0, $product['has_product_variants']);

	}

	public function testImportNewVariants()
	{
		$product = $this->ef->newProduct(['variants' => false]);

		$data = $this->makeData($product, [
			['name' => "Grade",
			 'product_option_values' => [
				 ['value' => "A"],
				 ['value' => "B"],
				 ['value' => "C"]
			]],
			['name' => "Size",
			 'product_option_values' => [
				 ['value' => "Small"],
				 ['value' => "Medium"],
				 ['value' => "Large"]
			]]
		]);

		$a_small_variant_price = 9.99;
		$data['variants'][0]['price'] = $a_small_variant_price;

		$this->assertArrayHasKey('options', $data);
		$this->assertArrayHasKey('variants', $data);
		$this->assertEquals(2, count($data['options']));
		$this->assertEquals(9, count($data['variants']));

		$before_num_variants = $this->ea->count('product_variants', [
			'product_id' => $product['id'],
			'deleted' => null
		]);
		$this->assertEquals(1, $before_num_variants);

		$this->importer->import($data);

		$after_num_variants = $this->ea->count('product_variants', [
			'product_id' => $product['id'],
			'deleted' => null
		]);
		$this->assertEquals(9, $after_num_variants);


		$grade_option = $this->ea->get('product_options', [
			'name' => 'Grade',
			'product_id' => $product['id']
		]);
		$this->assertIsNumeric($grade_option['id']);

		$size_option = $this->ea->get('product_options', [
			'name' => 'Size',
			'product_id' => $product['id']
		]);
		$this->assertIsNumeric($size_option['id']);

		$grade_a = $this->ea->get('product_option_values', [
			'value' => 'A',
			'product_option_id' => $grade_option['id']
		]);
		$this->assertIsNumeric($grade_a['id']);

		$size_medium = $this->ea->get('product_option_values', [
			'value' => 'Medium',
			'product_option_id' => $size_option['id']
		]);
		$this->assertIsNumeric($size_medium['id']);

		$a_med_variant = $this->ea->get('product_variants', [
			'and',
			['=', 'product_id', $product['id']],
			['=', 'grade:product_variant_option_values.product_option_value.value', 'A'],
			['=', 'grade:product_variant_option_values.product_option_value.product_option.name', 'Grade'],
			['=', 'size:product_variant_option_values.product_option_value.value', 'Medium'],
			['=', 'size:product_variant_option_values.product_option_value.product_option.name', 'Size'],
		]);

		$this->assertIsNumeric($a_med_variant['id']);
		$this->assertNull($a_med_variant['quantity']);
		$this->assertNull($a_med_variant['image_url']);
		$this->assertNull($a_med_variant['sku']);

		$a_small_variant = $this->ea->get('product_variants', [
			'and',
			['=', 'product_id', $product['id']],
			['=', 'grade:product_variant_option_values.product_option_value.value', 'A'],
			['=', 'grade:product_variant_option_values.product_option_value.product_option.name', 'Grade'],
			['=', 'size:product_variant_option_values.product_option_value.value', 'Small'],
			['=', 'size:product_variant_option_values.product_option_value.product_option.name', 'Size'],
		]);

		$this->assertEquals($a_small_variant_price, $a_small_variant['price']);

	}

	public function testImportUpdateVariants() {
		$product = $this->ef->newProduct();

		$options = $this->ea->list('product_options',
								   ['product_id' => $product['id']],
								   ['expand' => 'product_option_values']);


		$num_product_variants = $this->ea->count('product_variants', [
			'product_id' => $product['id']
		]);

		$this->assertTrue($num_product_variants > 3);

		$data = $this->makeData($product, $options);

		$this->assertEquals($num_product_variants, count($data['variants']));

		foreach($data['variants'] as $i => $pv) {
			$this->assertIsNumeric($pv['id']);
			$verify = $this->ea->get('product_variants', ['id' => $pv['id']]);
			$this->assertEquals($pv['id'], $verify['id']);
			$data['variants'][$i]['sku'] = "aaa-" . $pv['id'];
		}

		$this->importer->import($data);

		$product_variants = $this->ea->list('product_variants', [
			'product_id' => $product['id']
		]);
		foreach($product_variants as $pv) {
			$this->assertEquals("aaa-" . $pv['id'], $pv['sku']);
		}
	}

	private function makeData($product, $options) {
		$seq = 0;
		$options_expanded = array_map(function($o) use(&$seq) {
			return [
				'id' => $o['id'] ?? $this->nextLocalId(),
				'name' => $o['name'] ?? nc_random_token(),
				'product_option_type_id' => $o['product_option_type_id'] ??
										  ProductOptionTypes::text()->id,
				'product_option_values' => array_map(function($v) use(&$seq) {
					$value = $v['value'] ?? nc_random_token();
					return [
						'id' => $v['id'] ?? $this->nextLocalId(),
						'value' => $v['value'] ?? $value,
						'display_value' => $v['display_value'] ?? $value,
						'weight' => $v['weight'] ?? '',
						'price_offset' => $v['price_offset'] ?? '0',
						'is_price_offset_percent' => $v['is_price_offset_percent'] ?? 'false',
						'sequence' => $v['sequence'] ?? ++$seq
					];
				}, $o['product_option_values'] ?? [])
			];
		}, $options);

		$variants_source = array_map(function($o) { return $o['product_option_values']; },
									 $options_expanded);

		$seq = 0;
		$variants = nc_permute($variants_source, function($carry, $option_values) use(&$seq) {
			$lookup_clause = [];
			foreach($option_values as $i => $ov) {
				$lookup_clause[] = [
					"=",
					"ov$i:product_variant_option_values.product_option_value.id",
					$ov['id']
				];
			}

			$pv = $this->ea->get('product_variants', ['and', $lookup_clause]);
			if(!$pv) {
				$pv = [
					'id' => $this->nextLocalId(),
					'sequence' => ++$seq,
					'visible' => 'true',
					'price' => '',
					'sku' => '',
					'image_url' => '',
					'quantity' => ''
				];
			}
			$pv['signature'] = implode(':', array_map(function($ov) { return $ov['id']; }, $option_values));
			$carry[] = $pv;
			return $carry;
		}, []);

		return [
			'product_id' => $product['id'],
			'has_product_variants' => 'on',
			'options' => $options_expanded,
			'variants' => $variants
		];
	}

	private function nextLocalId()
	{
		return 'L' . (++$this->localIdSource);
	}
}
