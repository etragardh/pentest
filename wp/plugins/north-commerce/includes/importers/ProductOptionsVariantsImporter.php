<?php
namespace NorthCommerce\Importers;

use NorthCommerce\Db\Collections\ProductVariantTypes as VariantTypes;
use North_Commerce_Db_Agent;
use Exception;

/**
 * Importer of Product Options and Variant data into an existing Product.
 *
 * @package north-commerce/includes/models
 * @author  North Commerce <hello@northplugins.com>
 * @link    https://northcommerce.com/
 * @since   0.1.16
 * @version 0.1.24
 */
class ProductOptionsVariantsImporter {

	private $ea;
	private $agent;

	function __construct() {
		$this->ea = North_Commerce_Db_Agent::instance()->entityAccess();
		$this->agent = North_Commerce_Db_Agent::instance();
	}

	/**
	 * @version 0.1.21
	 */
	public function import( $form_data ) {
		return $this->agent->withTx( function() use ( $form_data ) {
			$product = $this->ea->get( 'products', [ 'id' => $form_data['product_id' ] ]);
			$env = [];
			$product_options = $form_data['options'] ?? [];
			$product_variants = $form_data['variants'] ?? [];

			$env = $this->importProductOptions( $product, $product_options, $env );
			$env = $this->importProductVariants( $product, $product_variants, $env );

			$form_data['has_product_variants']
				? $this->deleteSoloVariant( $product )
				: $this->refreshSoloVariant( $product );
		} );
	}

	/**
	 * @version 0.1.21
	 */
	private function importProductOptions( $product, $option_data, $env ) {
		return $this->importData(
			'product_options',
			[ 'product_id' => $product['id'] ],
			function ( $od ) use ( $product ) {
				return [
					'product_id' => $product['id'],
					'name' => trim( $od['name'] ),
					'product_option_type_id' => $od['product_option_type_id'],
					'sequence' => $od['sequence'] ?: null
				];
			},
			function ( $od, $entity, $env ) {
				return $this->importProductOptionValues( $od, $env );
			},
			$option_data,
			$env
		);
	}

	/**
	 * @version 0.1.24
	 */
	private function importProductOptionValues( $product_option, $env ) {
		$columns_fmt_rules = [
			'string' => [ 'display_value', 'value' ]
		];

		return $this->importData(
			'product_option_values',
			[ 'product_option_id' => $product_option['id'] ],
			function( $ovd, $env ) use ( $product_option ) {
				return [
					'product_option_id' => nc_g( $env, $product_option['id'], $product_option['id'] ),
					'display_value' => $ovd['display_value'],
					'value' => wp_unslash( $ovd['value'] ),
					'price_offset' => $ovd['price_offset'],
					'is_price_offset_percent' => $ovd['is_price_offset_percent'] == 'true',
					'weight' => $ovd['weight'],
					'sequence' => $ovd['sequence']
				];
			},
			function( $ovd, $entity, $env ) {
				return $env;
			},
			$product_option['product_option_values'] ?? [],
			$env,
			$columns_fmt_rules
		);
	}

	/**
	 * @version 0.1.20
	 */
	private function importProductVariants( $product, $variant_data, $env ) {
		$columns_fmt_rules = [
			'string' => [ 'slug' ]
		];

		return $this->importData(
			'product_variants',
			[ 'product_id' => $product['id'] ],
			function ( $vd, $env ) use ( $product ) {
				return [
					'slug' => $vd['slug'],
					'visible' => $vd['visible'] == 'true',
					'product_variant_type_id' => VariantTypes::standard()->id,
					'product_id' => $product['id'],
					'sku' => '' == $vd['sku'] ? null : $vd['sku'],
					'price' => '' == $vd['price'] ? null : $vd['price'],
					'quantity' => '' == $vd['quantity'] ? null : $vd['quantity'],
					'image_url' => '' == $vd['image_url'] ? null : $vd['image_url'],
					'sequence' => $vd['sequence']
				];
			},
			function ( $ovd, $entity, $env ) {
				if ( ! isset( $ovd['signature'] ) ) {
					throw new Exception( 'No signature set' );
				}
				$variant_option_value_data = array_map(
					function ( $id ) use ( $env, $entity ) {
						$existing = $this->ea->get( 'product_variant_option_values', [
							'product_variant_id' => $entity['id'],
							'product_option_value_id' => nc_g( $env, $id, $id )
						] );

						if ( ! is_numeric( nc_g( $env, $id, $id ) ) ) {
							throw new Exception( "Can't map: $id to real id. " . print_r( $env, true ) );
						}

						return [
							'id' => $existing ? $existing['id'] : 'L' . md5( $entity['id'] . $id . microtime( true ) ),
							'product_option_value_id' => nc_g( $env, $id, $id )
						];
					},
					explode( ':', $ovd['signature'] )
				);

				return $this->importProductVariantOptionValues( $entity, $variant_option_value_data, $env );
			},
			$variant_data,
			$env,
			$columns_fmt_rules
		);
	}

	private function deleteSoloVariant( $product ) {
		$solo_pv = $this->ea->get( 'product_variants', [
			'product.id' => $product['id'],
			'product_variant_type_id' => VariantTypes::solo()->id
		] );

		if ( ! $solo_pv ) {
			return;
		}

		$this->ea->update( 'product_variants', $solo_pv, [
			'delete' => $this->agent->sqlTimestamp( time() )
		] );
	}

	private function refreshSoloVariant( $product ) {
		$pvt_solo = VariantTypes::solo();

		$solo_pv = $this->ea->get( 'product_variants', [
			'product.id' => $product['id'],
			'product_variant_type_id' => $pvt_solo->id,
			'deleted' => [ 'any' ]
		] );

		$details = [
			'product_id' => $product['id'],
			'product_variant_type_id' => $pvt_solo->id,
			'sequence' => 1,
			'visible' => true,
			'deleted' => null
		];

		if ( $solo_pv ) {
			$this->ea->update( 'product_variants', $solo_pv, $details );
			return;
		}

		$this->ea->create( 'product_variants', $details );
	}

	private function importProductVariantOptionValues( $product_variant, $variant_option_value_data, $env ) {
		return $this->importData(
			'product_variant_option_values',
			[ 'product_variant_id' => $product_variant['id'] ],
			function ( $vovd ) use ( $product_variant ) {
				$attrs = [
					'product_variant_id' => $product_variant['id'],
					'product_option_value_id' => $vovd['product_option_value_id'],
				];
				return $attrs;
			},
			function ( $vovd, $entity, $env ) { return $env; },
			$variant_option_value_data,
			$env
		);

	}

	/**
	 * @version 0.1.20
	 */
	private function importData(
		$table,
		$find_all_criteria,
		$data_to_entity_attrs,
		$on_data_stored,
		$data,
		$env,
		$columns_fmt_rules = null
	) {
		$before = array_reduce(
			$this->ea->list( $table, $find_all_criteria ), function( $carry, $entity ) {
				$carry[$entity['id']] = $entity;
				return $carry;
			},
			[]
		);

		$data = $data ?: [];
		foreach ( $data as $index => $entry ) {
			$entity = null;
			$entity_attrs = $data_to_entity_attrs( $entry + ['sequence' => $index + 1], $env );

			if ( ! isset( $entry['id'] ) ) {
				throw new Exception( "No id attr found for $table: " . print_r( $entry, true ));
			}

			if ( $this->isLocalId( $entry['id'] ) ) {
				$entity = $this->ea->create( $table, $entity_attrs, [], $columns_fmt_rules );
				$env[ $entry['id'] ] = $entity['id'];
			} else {
				[ $entity, $before ] = nc_array_pluck( $before, $entry['id'], false );
				if ( ! $entity ) {
					throw new Exception(
						"$table {$entry['id']} isn't associated with $table: "
						. print_r( $find_all_criteria, true )
						. "\n"
						. print_r( $before, true )
					);
				}
				$entity = $this->ea->update( $table, $entity, $entity_attrs, [], $columns_fmt_rules );
			}
			$env = $on_data_stored( $entry, $entity, $env );
		}

		foreach ( $before as $id => $to_delete ) {
			unset( $id );
			$this->ea->update( $table, $to_delete, [
				'deleted' => $this->agent->sqlTimestamp( time() )
			] );
		}

		return $env;
	}

	private function isLocalId( $id ) {
		return strpos( $id, 'L' ) === 0;
	}

}
