<?php

require_once __DIR__ . '/sql/SqlConstruct.php';
require_once __DIR__ . '/sql/Expression.php';
require_once __DIR__ . '/sql/Operator.php';
require_once __DIR__ . '/sql/BinaryOperator.php';
require_once __DIR__ . '/sql/NaryOperator.php';
require_once __DIR__ . '/sql/UnaryOperator.php';
require_once __DIR__ . '/sql/LiteralValue.php';
require_once __DIR__ . '/sql/NullValue.php';
require_once __DIR__ . '/sql/ListValue.php';
require_once __DIR__ . '/sql/ColumnReference.php';
require_once __DIR__ . '/sql/TrueValue.php';
require_once __DIR__ . '/sql/FalseValue.php';
require_once __DIR__ . '/sql/Join.php';
require_once __DIR__ . '/sql/Joins.php';
require_once __DIR__ . '/sql/ColumnList.php';

use \NorthCommerce\Db\Sql;

/**
 * DB Parser class.
 *
 * Parses various aspects of database related code.
 *
 *
 * @package north-commerce/admin
 * @author  North Commerce <hello@northplugins.com>
 * @link    https://northcommerce.com/
 * @since   0.1.3
 * @version 0.1.25
 */
class North_Commerce_Db_Parser {

	public function verifyTable( $table, $options = [] ) {
		$agent = North_Commerce_Db_Agent::instance();
		$schema = $agent->schema();
		return $schema->getColumns( $table, [ 'not_found' => false ] )
			? true
			: nc_opt_ex( "$table not found", $options );
	}

	public function columnList( $table, $named_cols = [] ): sql\ColumnList {
		$agent = North_Commerce_Db_Agent::instance();
		$schema = $agent->schema();

		$columns = array_keys( $schema->getColumns( $table ) );
		foreach ( $columns as $i => $col ) {
			if ( $named_cols && ! in_array( $col, $named_cols ) ) {
				unset( $columns[ $i] );
			}
		}

		return new sql\ColumnList( $table, $columns );
	}

	/**
	 * @version 0.1.25
	 */
	public function parseFilter( $table, $input, $options = [] ) : sql\Expression {
		if ( $input === true || $input === false || $input === null ) {
			return $this->valueify( $table, $input );
		}

		if ( is_string( $input ) ) {
			return $this->parseFilterString( $table, $input );
		}

		if ( nc_is_assoc_array( $input ) ) {
			return $this->parseFilterAssocArray( $table, $input );
		}

		return $this->parseFilterSeqArray( $table, $input, $options );
	}

	private function parseFilterString( $table, $input ) {
		$clauses = explode( ',', $input );
		$expr = [ 'and' ];

		foreach ( $clauses as $c ) {
			[ $lhs, $op, $rhs ] = explode( ':', $c );
			$expr[] = [ $op, $lhs, $rhs ];
		}

		return $this->parseFilter( $table, $expr );
	}

	private function parseFilterAssocArray( $table, $input ) {
		$expr = [ 'and' ];
		foreach ( $input as $k => $v ) {
			if ( is_array( $v ) && count( $v ) == 2 ) {
				$expr[] = [ $v[0], $k, $v[1] ];
			} elseif ( is_array( $v ) && count( $v ) == 1 ) {
				$expr[] = [ $v[0], $k ];
			} elseif ( is_array( $v ) ) {
				throw new Exception( "Don't know how to parse the expr: " . print_r( $v, true ) );
			} else if ( $v === null ) {
				$expr[] = [ 'is', $k, null ];
			} else {
				$expr[] = [ '=', $k, $v ];
			}
		}

		return $this->parseFilter( $table, $expr );
	}

	private function parseFilterSeqArray( $table, $input ) {
		$op = $this->unaliasOperator( strtolower( array_shift( $input ) ) );
		switch( $op ) {
			case '=':
			case '>':
			case '<':
			case '<=':
			case '>=':
			case '<>':
			case 'like':
			case 'is':
				$this->hasNArgs( $input, 2 );
				return new sql\BinaryOperator(
					$op,
					is_numeric( $input[0] )
						? $this->valueify( $table, $input[0] )
						: new sql\ColumnReference( $table, $input[0] ),
					$this->valueify( $table, $input[1] )
				);

			case 'in':
				$this->hasNArgs( $input, 2 );

				if ( ! nc_is_seq_array( $input[1] ) ) {
					throw new Exception( 'IN operator requires a second be an array' );
				}

				return new sql\BinaryOperator(
					$op,
					is_numeric( $input[0] )
						? $this->valueify( $table, $input[0] )
						: new sql\ColumnReference( $table, $input[0] ),
					new sql\ListValue(
						array_map(
							function( $v ) use( $table ) {
								return $this->valueify( $table, $v );
							},
							$input[1]
						)
					)
				);

			case 'not':
				$this->hasNArgs( $input, 1 );
				return new sql\UnaryOperator(
					$op,
					$this->valueify( $table, $input[0] )
				);

			case 'any':
				$this->hasNArgs( $input, 1 );
				return new sql\AnyOperator( new sql\ColumnReference( $table, $input[0] ) );

			case 'and':
			case 'or':
				$input = $this->flatten( $input );
				$this->hasAtLeastArgs( $input, 1 );
				$expanded = array_map(
					function( $expr ) use( $table ) {
						return $this->parseFilter( $table, $expr );
					},
					$input
				);
				return new sql\NaryOperator( $op, $expanded );

			default:
				throw new Exception( "Can't parse the operator: [$op]" );
		}
	}

	/**
	 * @version 0.1.25
	 */
	private function valueify( $table, $input ) {
		if ( is_array( $input ) && nc_is_seq_array( $input ) ) {
			return $this->parseFilter( $table, $input );
		}

		if ( $input === null ) {
			return new sql\NullValue();
		}

		if ( $input === false ) {
			return new sql\FalseValue();
		}

		if ( $input === true ) {
			return new sql\TrueValue();
		}

		if ( is_string( $input ) || is_numeric( $input ) ) {
			return new sql\LiteralValue( $input );
		}

		throw new Exception( 'Unable to coerce ' . print_r( $input, true ) .  ' to an SQL value.' );
	}

	private function unaliasOperator( $operator ) {
		$aliases = [
			'lt' => '<',
			'lte' => '<=',
			'gt' => '>',
			'gte' => '>=',
			'eq' => '=',
			'equal' => '=',
		];

		return nc_g( $aliases, $operator, $operator );
	}

	/**
	 * @version 0.1.25
	 */
	private function hasNArgs( $inputs, $num ) {
		if ( count( $inputs ) == $num ) {
			return $inputs;
		}

		throw new Exception(
			"expected $num args, got: "
			. count( $inputs )
			. ": "
			. print_r( $inputs, true )
		);
	}

	private function hasAtLeastArgs( $inputs, $num ) {
		if ( count( $inputs ) < $num ) {
			throw new Exception(
				"expected at least $num args, got: " . count( $inputs )
			);
		}

		return $inputs;
	}

	private function flatten( $inputs ) {
		$buffer = [];
		foreach ( $inputs as $input ) {
			if (
				nc_is_seq_array( $input )
				&& count( $input ) > 0
				&& nc_is_seq_array( $input[0] )
			) {
				$buffer = array_merge( $buffer, $input );
			} else {
				$buffer[] = $input;
			}
		}
		return $buffer;
	}
}
