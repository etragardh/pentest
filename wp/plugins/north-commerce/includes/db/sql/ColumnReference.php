<?php
namespace NorthCommerce\Db\Sql;

use North_Commerce_Db_Agent;

/**
 * Class for referring to a column. A column reference can be a simple
 * column name, like 'slug' or it can be a dotted expression that refers
 * to joined tables like 'orders.sku'.
 *
 * A column expression can only be interpreted in the context of a
 * source table.
 *
 * orders.billing_address.country.id
 * alias:orders.billing_address.country.id
 *
 * makes sense if source_table is 'customers' but makes no sense
 * if the source_table is 'products'.
 *
 * @since 0.1.3
 */
class ColumnReference extends Expression {

	private $source_table;
	private $column_expr;
	private $column;
	private $table;
	private $joins;
	private $alias_prefix;

	function __construct( $source_table, $column_expr ) {
		$agent = North_Commerce_Db_Agent::instance();
		$schema = $agent->schema();
		$this->source_table = $source_table;
		[$this->alias_prefix, $this->column_expr] = $this->parseColumnExpr($column_expr);

		$this->joins = [];

		$current_table = $this->source_table;
		$next_prefix = $this->alias_prefix;
		$current_prefix = '';
		$parts = explode('.', $this->column_expr);
		while(count($parts) > 1) {
			$next = array_shift($parts);
			$id_ref = $schema->idRefTable($current_table,
										  "{$next}_id", ['not_found' => false]);
			$table_ref = $schema->tableRefColumn($next,
												 $current_table, ['not_found' => false]);
			if($id_ref) {
				$this->joins[] = new Join($current_prefix, $current_table, "{$next}_id",
										   $next_prefix, $id_ref, "id", true, true);
				$current_table = $id_ref;
				$current_prefix = $next_prefix;
			} elseif($table_ref) {
				$this->joins[] = new Join($current_prefix, $current_table, "id",
										  $next_prefix, $next, $table_ref, true, false);
				$current_table = $next;
				$current_prefix = $next_prefix;
			} else {
				throw new \Exception("[$this->source_table] [$column_expr]: " .
									"Expected [$next] to be a table or id ref. Found something else");
			}
		}

		$this->column = array_shift($parts);
		if(!nc_g($schema->tableCols($current_table), $this->column)) {
			throw new \Exception("[source_table] [$column_expr]: " .
								 "{$this->column} not found on $current_table");
		}
		$this->table = $current_table;
	}

	public function toSql() {
		return "{$this->alias_prefix}{$this->table}.{$this->column}";
	}

	function sourceTable() {
		return $this->source_table;
	}

	function table() {
		return $this->table;
	}

	function column() {
		return $this->column;
	}

	function columnExpr() {
		return $this->column_expr;
	}

	function joins() {
		$joins = new Joins();
		$joins->add($this->joins);
		return $joins;
	}

	private function parseColumnExpr($name) {
		return strpos($name, ':') === false ? ['', $name] : explode(':', $name);
	}
}
