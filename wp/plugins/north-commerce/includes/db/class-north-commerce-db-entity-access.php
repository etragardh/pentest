<?php

define( 'NORTH_COMMERCE_DB_STORE_STRATEGY_ATTR_VALUE', 'attr_value' );
define( 'NORTH_COMMERCE_DB_STORE_STRATEGY_ATTR_REF', 'attr_ref' );
define( 'NORTH_COMMERCE_DB_STORE_STRATEGY_TABLE_REF', 'table_ref' );
define( 'NC_DB_ENTITY_ACCESS_CREATED', 'nc_db_entity_access_created' );
define( 'NC_DB_ENTITY_ACCESS_UPDATED', 'nc_db_entity_access_updated' );
define( 'NC_DB_ENTITY_ACCESS_CREATE_VALUES', 'nc_db_entity_access_create_values' );
define( 'NC_DB_ENTITY_ACCESS_UPDATE_CHANGES', 'nc_db_entity_access_update_changes' );
define( 'NC_DB_ENTITY_ACCESS_CRITERIA', 'nc_db_entity_access_criteria' );
define( 'NC_DB_ENTITY_ACCESS_STORE_CHANGES', 'nc_db_entity_access_store_changes' );
define( 'NC_DB_ENTITY_ACCESS_DELETE_CRITERIA', 'nc_db_entity_access_delete_criteria' );
define( 'NC_DB_ENTITY_ACCESS_DELETED', 'nc_db_entity_access_deleted' );
define( 'NC_DB_PANIC', '*panic*' );

/**
 * Database Entity Access
 *
 * Class for allowing access to the database entities defined in the schema.
 * This provides higher level access than making raw SQL queries
 *
 * @package north-commerce/includes/db
 * @author  North Commerce <hello@northplugins.com>
 * @link    https://northcommerce.com/
 * @since   0.1.3
 * @version 0.1.20
 */
class North_Commerce_Db_Entity_Access {

	private static $instance;

	public static function instance(): North_Commerce_Db_Entity_Access {
		if ( self::$instance == null ) {
			self::$instance = new North_Commerce_Db_Entity_Access();
		}
		return self::$instance;
	}

	private $expander;
	private $parser;
	private $agent;
	private $id_manager;

	function __construct() {
		$this->agent    = North_Commerce_Db_Agent::instance();
		$this->expander = $this->agent->expander();
		$this->parser   = $this->agent->parser();
		$this->id_manager = $this->agent->idManager();
	}

	public function get( $table, $criteria, $options = [] ) {
		$found = $this->list( $table, $criteria, [ 'limit' => 1 ] + $options );

		if ( $found ) {
			return $this->maybeExpand( $table, $found[0], $options );
		}

		$not_found = nc_g( $options, 'not_found', null );
		if ( $not_found == NC_DB_PANIC ) {
			throw new \NcNotFoundException("Can't find: $table: " . print_r($criteria, true));
		}
		return $not_found;
	}

	/**
	 * Reference: look up an entity by ID.
	 */
	public function ref( $id, $options = [] ) {
		$table = nc_g(
			$options,
			'table',
			$this->id_manager->tableFromId( $id )
		);

		if ( ! $table ) {
			throw new \NcNotFoundException("Can't determine table from $id");
		}

		return $this->get( $table, compact( 'id' ), $options );
	}

	public function list( $table, $criteria, $options = [] ) {
		$criteria = apply_filters( NC_DB_ENTITY_ACCESS_CRITERIA, $criteria, $table );
		$schema = $this->agent->schema();
		$prefix = $schema->getTablePrefix();
		$columns = $this->parser->columnList( $table, nc_g( $options, 'columns' ) );
		$filter = $this->parser->parseFilter( $table, $criteria );
		$joins = $filter->joins();
		$limit = nc_g( $options, 'limit', 0 );
		$offset = nc_g( $options, 'offset', 0 );
		$order_by = nc_g( $options, 'order_by', "$table.id" );
		$distinct = nc_g( $options, 'distinct', false ) ? 'DISTINCT' : '';
		$where_sql = $filter->toSql();
		$join_sql = $joins->toSql();
		$group_by_sql = $joins->allOneToOne() ? '' : " GROUP BY $table.id";
		$for_sql = ( $f = nc_g( $options, 'for', false ) ) ? " FOR $f" : '';

		$sql = "SELECT $distinct {$columns->toSql()}"
			. " FROM {$prefix}$table $table $join_sql"
			. " WHERE $where_sql"
			. $group_by_sql
			. " ORDER BY $order_by "
			. ( $limit ? " LIMIT $offset, $limit" : '' )
			. $for_sql;

		return $this->maybeExpand( $table, $this->agent->getResults( $sql, [], $options ), $options );
	}

	/**
	 * List allowed values for ENUM type column
	 *
	 * @since 0.1.20
	 */
	public function list_column_enums( $table, $column_name, $options = [] ) {
		$schema = $this->agent->schema();
		$prefix = $schema->getTablePrefix();
		$columnList = $this->parser->columnList( $table, nc_g( $options, 'columns' ) );

		if ( ! in_array( $column_name, $columnList->get_columns() ) ) {
			throw new Exception( "Can't find column by provided name: " . $column_name );
		}

		$sql = "SHOW COLUMNS FROM {$prefix}{$table} WHERE Field = '{$column_name}'";

		$column_data = $this->agent->getResults( $sql, [], $options );
		$column_type = $column_data[0]['Type'];
		preg_match( "/^enum\(\'(.*)\'\)$/", $column_type, $matches );

		if ( empty( $matches[1] ) ) {
			throw new Exception( "There is no ENUM values for provided column" );
		}

		$enum_values = explode( "','", $matches[1] );
        return $enum_values;
	}

	public function count( $table, $criteria ) {
		$criteria = apply_filters( NC_DB_ENTITY_ACCESS_CRITERIA, $criteria, $table );
		$this->parser->verifyTable($table);
		$prefix = $this->agent->schema()->getTablePrefix();
		$filter = $this->parser->parseFilter($table, $criteria);
		$joins = $filter->joins();
		$where_sql = $filter->toSql();
		$join_sql = $joins->toSql();

		$sql = "SELECT COUNT(DISTINCT $table.id) " .
			   "FROM {$prefix}$table $table $join_sql " .
			   "WHERE $where_sql";

		return $this->agent->getVar($sql);
	}

	/**
	 * @version 0.1.20
	 */
	public function create( $table, $values, $options = [], $fmt_rules = null ) {
		if ( isset( $values['id'] ) ) {
			throw new Exception( "Can't set id on a created object" );
		}

		$this->parser->verifyTable( $table );

		global $wpdb;
		$agent = North_Commerce_Db_Agent::instance();
		$prefix = $agent->schema()->getTablePrefix();

		$values = apply_filters(NC_DB_ENTITY_ACCESS_CREATE_VALUES, $values, $table);

		$id = $this->id_manager->freshId( $table );
		if ( $id ) {
			$values['id'] = $id;
		}

		$col_names = $this->fmtInsertColNames( $values );
		$col_values = $this->fmtInsertColValues( $values, $fmt_rules );

		$sql = "INSERT INTO {$prefix}{$table}($col_names) VALUES ($col_values);";
		$agent->query( $sql );
		if ( ! $id ) {
			$id = $wpdb->insert_id;
		}
		$created = $this->get( $table, [ 'id' => $id ], $options );

		return apply_filters( NC_DB_ENTITY_ACCESS_CREATED, $created, $table, $values );
	}

	/**
	 * @version 0.1.20
	 */
	public function update( $table, $existing, $changes, $options = [], $fmt_rules = null ) {
		if ( isset( $changes['id'] ) ) {
			throw new Exception( "Can't set an id value" );
		}

		if ( ! isset( $existing['id'] ) ) {
			throw new Exception( "Can't determine object to update" );
		}

		global $wpdb;

		$this->parser->verifyTable( $table );
		$agent = North_Commerce_Db_Agent::instance();
		$prefix = $agent->schema()->getTablePrefix();
		$changes = apply_filters(NC_DB_ENTITY_ACCESS_UPDATE_CHANGES, $changes, $table, $existing);
		$sets = $this->fmt_update_sets( $changes, $fmt_rules );
		$id_esc = $this->id_manager->idStyle( $table ) == NC_DB_ID_NUMERIC_STYLE ? '%d' : '%s';

		$sql = $wpdb->prepare( "UPDATE {$prefix}{$table} {$table} SET $sets WHERE $table.id = $id_esc", $existing['id'] );
		$agent->query( $sql );
		$updated = $this->get( $table, [ 'id' => $existing['id'] ], $options );

		return apply_filters(NC_DB_ENTITY_ACCESS_UPDATED, $updated, $table, $existing, $changes);
	}

	/**
	 * Similar to update and create, but smarter. If $changes contains
	 * an id, then we know we want to Update. Otherwise, we do a Create.
	 * Also supports nested object handling
	 */
	public function store( $table, $changes, $options = [] ) {
		$this->parser->verifyTable( $table );
		$changes = apply_filters( NC_DB_ENTITY_ACCESS_STORE_CHANGES, $changes, $table );
		$agent = North_Commerce_Db_Agent::instance();
		return $agent->withTx( function() use ( $table, $changes, $options ) {
			$depth = nc_g( $options, 'depth', 0 );

			$existing = false;

			if ( isset( $changes['id'] ) ) {
				$existing = $this->get( $table, [ 'id' => $changes['id'] ] );
				if ( ! $existing ) {
					throw new NcDbEntityAccessException( "Provided ID doesn't reference an existing object." );
				}
				unset( $changes['id'] );
			}

			$also_store = [];

			foreach ( $changes as $col => $value ) {
				$strategy = $this->attrStoreStrategy($table, $col, $value);
				switch ( $strategy['type'] ) {
					case NORTH_COMMERCE_DB_STORE_STRATEGY_ATTR_VALUE:
						break;

					case NORTH_COMMERCE_DB_STORE_STRATEGY_ATTR_REF:
						unset( $changes[ $col ] );
						$ref_entity = $this->store(
							$strategy['dest_table'],
							$value,
							[ 'depth' => $depth + 1 ]
						);
						$changes["{$col}_id"] = $ref_entity['id'];
						break;

					case NORTH_COMMERCE_DB_STORE_STRATEGY_TABLE_REF:
						unset($changes[$col]);
						$also_store[] = [
							'table' => $col,
							'source_col' => $strategy['source_col'],
							'entities' => $value
						];
						break;

					default:
						throw new NcDbEntityAccessException("Don't know how to store $table.$col (" . print_r($strategy) . ")");
				}
			}

			if ( empty( $changes ) ) {
				$saved = $existing ? $existing : $changes;
			} else {
				if ( $existing ) {
					$saved = $this->update( $table, $existing, $changes );
				} else {
					$saved = $this->create( $table, $changes );
				}
			}

			foreach ( $also_store as $as ) {
				foreach ( $as['entities'] as $e ) {
					$e[ $as['source_col'] ] = $saved['id'];
					$this->store(
						$as['table'],
						$e,
						[ 'depth' => $depth + 1 ]
					);
				}
			}

			return $this->maybeExpand( $table, $saved, $options );
		} );
	}

	/**
	 * Given a result set, consider expanding it per
	 * the requested `expand` optional parameter.
	 */
	private function maybeExpand( $table, $value, $options ) {
		$expand = nc_g( $options, 'expand' );

		if ( $expand ) {
			if ( nc_is_seq_array( $value ) ) {
				return array_map(
					function ( $v ) use ( $table, $expand ) {
						return $this->expander->expand( $table, $v, $expand );
					},
					$value
				);
			}

			return $this->expander->expand( $table, $value, $expand );
		}

		return $value;
	}

	/**
	 * Given a table, column and value, how should
	 * we store this value in the table?
	 *
	 * Return false if we don't know how to store the value.
	 */
	public function attrStoreStrategy( $table, $col, $value ) {
		$agent = North_Commerce_Db_Agent::instance();
		$schema = $agent->schema();
		$cols = $schema->tableCols($table);

		if(nc_is_seq_array($value) && ($c = $schema->tableRefColumn($col, $table, ['not_found' => false]))) {
			return [
				'type' => NORTH_COMMERCE_DB_STORE_STRATEGY_TABLE_REF,
				'source_col' => $c
			];
		} elseif(nc_is_assoc_array($value) && ($t = $schema->idRefTable($table, "{$col}_id", ['not_found' => false]))) {
			return [
				'type' => NORTH_COMMERCE_DB_STORE_STRATEGY_ATTR_REF,
				'dest_table' => $t
			];
		} elseif(nc_g($cols, $col)) {
			return [
				'type' => NORTH_COMMERCE_DB_STORE_STRATEGY_ATTR_VALUE
			];
		} else {
			return [
				'type' => false
			];
		}
	}

	/**
	 * @since   0.1.3
	 * @version 0.1.13
	 */
	public function delete( $table, $criteria, $options = [] ) {
		$criteria = apply_filters( NC_DB_ENTITY_ACCESS_CRITERIA, $criteria, $table );
		$criteria = apply_filters( NC_DB_ENTITY_ACCESS_DELETE_CRITERIA, $criteria, $table );
		$this->parser->verifyTable($table);
		$inspector = $this->agent->introspector();
		$prefix = $this->agent->schema()->getTablePrefix();
		$filter = $this->parser->parseFilter( $table, $criteria );
		$where = $filter->toSql( $table_prefix = true );
		$join = $filter->joins()->toSql();

		if ( nc_g( $options, 'recursive' ) ) {
			$rows = $this->list( $table, $criteria );
			foreach ( $rows as $row ) {
				$inspector->reduceForeignKeys( $table, $row, function( $carry, $table, $entity ) {
					unset( $carry );
					return $this->delete( $table, [ 'id' => $entity['id'] ] );
				}, true );
			}
		} else {
			$all_cols = $this->agent->schema()->getColumns( $table );
			$to_remove = $this->list( $table, $criteria );
			if ( isset( $all_cols['deleted'] ) ) {
				foreach ( $to_remove as $entity ) {
					$this->update( $table, $entity, [ 'deleted' => $this->agent->sqlTimestamp( time() ) ] );
				}
			} else {
				$this->agent->query( "DELETE FROM {$prefix}{$table} {$join} WHERE $where" );
			}
			do_action( NC_DB_ENTITY_ACCESS_DELETED, $table, $criteria, $to_remove );
		}
	}

	/**
	 * @version 0.1.20
	 */
	private function fmt_update_sets( $changes, $fmt_rules = null ) {
		$agent = North_Commerce_Db_Agent::instance();
		$escaping_rules = $this->handle_escaping_rules( $fmt_rules );

		$statements = [];
		foreach ( $changes as $col_name => $value ) {
			$col_value = $agent->escSql(
				$value,
				$escaping_rules[ $col_name ] ?? null
			);

			$statements[] = "$col_name = $col_value";
		}

		return implode( ', ', $statements );
	}

	private function fmtInsertColNames( $values ) {
		$cols = array_keys($values);
		return implode(', ', $cols);
	}

	/**
	 * @version 0.1.20
	 */
	private function fmtInsertColValues( $values, $fmt_rules ) {

		$agent = North_Commerce_Db_Agent::instance();

		$escaping_rules = $this->handle_escaping_rules( $fmt_rules );

		$formatted_values = array_map(
			function( $v, $col_name ) use ( $agent, $escaping_rules ) {
				return $agent->escSql(
					$v,
					$escaping_rules[ $col_name ] ?? null
				);
			},
			$values,
			array_keys( $values )
		);

		return implode( ', ', $formatted_values );

	}

	/**
	 * @since   0.1.20
	 * @version 0.1.20
	 */
	private function handle_escaping_rules( $fmt_rules ):array {
		if ( ! $fmt_rules ) {
			return [];
		}

		foreach ( $fmt_rules as $type => $col_names ) {
			switch ( $type ) {
				case 'string':
				default: $fmt = '%s';
					break;
			}

			if (  is_string( $col_names ) ) {
				$rules[ $col_names ] = $fmt;
				continue;
			}

			if ( is_array( $col_names ) ) {
				foreach ( $col_names as $col_name ) {
					$rules[ $col_name ] = $fmt;
				}
			}
		}

		return $rules;
	}


}

class NcDbEntityAccessException extends Exception { }
