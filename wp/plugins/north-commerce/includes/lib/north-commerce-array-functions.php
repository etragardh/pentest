<?php
/*
 * A PHP file for implementing array related library funtions
 */

/*
 * utility function to making accessing an array easier.
 * 'g' gets an array value. If the value isn't set, then it uses $default.
 */
function nc_g($array, $key, $default = false) {
	if(!is_array($array)) {
		throw new Exception("Must provide array, provided " . print_r($array, true));
	}

	return array_key_exists($key, $array) ? $array[$key] : $default;
}

/*
 * like array_reduce but supports passing in a key, too.
 *
 *  callback = function($carry, $key, $valuue) { ... }
 */
function nc_array_kreduce($array, $callback, $init) {
	$carry = $init;
	foreach($array as $k => $v) {
		$carry = $callback($carry, $k, $v);
	}
	return $carry;
}

/*
 * Expand a key => value array using rules provided by
 * the caller.
 */
function nc_array_kexpand($array, $rules, $options = [])
{
	$unset = nc_g($options, 'unset', null);

	foreach($rules as $k => $fn) {
		$before = nc_g($array, $k, $unset);
		$after  = $fn($before, $array);
		$after  = is_array($after) ? $after : [$k => $after];
		unset($array[$k]);
		$array = $after + $array;
	}

	return $array;
}

/*
 * Grab a value from an array, returning back both
 * the value and the updated array.
 */
function nc_array_pluck($array, $key, $unset)
{
	$value = nc_g($array, $key, $unset);
	unset($array[$key]);
	return [ $value, $array ];
}

/**
 * Are we dealing with a sequential (vs associative) array?
 *
 * This isn't perfect, but it's fast and meets our needs.
 */
function nc_is_seq_array($array)
{
	return is_array($array) && (count($array) == 0 || isset($array[0]));
}

/**
 * Are we dealing with an associative array?
 * Not perfect, but quick our guess.
 */
function nc_is_assoc_array($array)
{
	return is_array($array) && !nc_is_seq_array($array);
}


define('NORTH_COMMERCE_OPT_NOT_FOUND', 'not_found');
define('NORTH_COMMERCE_OPT_THROW_EX', '*throw-ex*');

class NcNotFoundException extends Exception { }

/**
 * Check out options array for a not_found value. If one exists,
 * then use it.
 */
function nc_opt_ex( $message, $options ) {
	if (
		(
			$not_found = nc_g( $options, NORTH_COMMERCE_OPT_NOT_FOUND, NORTH_COMMERCE_OPT_THROW_EX )
		) == NORTH_COMMERCE_OPT_THROW_EX
	) {
		throw new NcNotFoundException($message);
	} else {
		return $not_found;
	}
}

/**
 * Like array_rand, but return the random value
 */
function nc_array_rand_value($array)
{
	$key = array_rand($array);
	return $array[$key];
}

/**
 * Given an array of arrays, form every combination of all the values.
 * We use the same $init / $carry behavior as array_reduce.
 *
 * Example:
 * nc_permute([[1,2,3], ['a', 'b']], function($carry, $combination) { ... }, [])
 *
 * cb will be called like so:
 * cb($carry, [1,'a'])
 * cb($carry, [1, 'b'])
 * cb($carry, [2, 'a'])
 * ...
 */
function nc_permute($arrays, $callback, $init, $accumulator = []) {
	if(count($arrays) == 0) {
		return $callback($init, $accumulator);
	}

	$focus = array_shift($arrays);
	if(!$focus) {
		return nc_permute($arrays, $callback, $init, $accumulator);
	}

	$carry = $init;
	foreach($focus as $elt) {
		$carry = nc_permute($arrays, $callback, $carry, array_merge($accumulator, [$elt]));
	}
	return $carry;
}
